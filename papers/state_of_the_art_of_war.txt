(State of) The Art of War: Offensive Techniques in Binary Analysis

مقدّمه:
این مقاله به طور عمده ۲ هدف دارد.
در ابتدا رویکردهای مختلفی که برای تحلیل خودکار فایل‌های باینری وجود دارند به عنوان پیش‌زمینه‌ی مقاله بیان می‌شوند تا خواننده با آخرین وضعیت تحقیقات در این زمینه آشنا شود.
در قسمت بعد ابزار angr معرّفی می‌شود که اکثر روش‌های مذکور در آن پیاده‌سازی شده‌اند. تجمیع پیاده‌سازی‌ها در یک چارچوب واحد این امکان را فراهم می‌کند که رویکردهای موجود بتوانند به خوبی با یکدیگر مقایسه شوند. در واقع یکی از نقاط قوّت این مقاله همین مقایسه‌ای است که انجام داده است و در گذشته به دلیل عدم تجمیع پیاده‌سازی‌ها مقایسه‌ای با این کیفیت میسّر نبود.
(در حقیقت برای من که به کلّی با این مبحث ناآشنا بودم قسمت اوّل خیلی مفیدتر بود چون باعث شد که شهود خوبی روی این مبحث به دست بیاورم.)
در این متن به موارد مربوط به angr نمی‌پردازیم. چون خیلی داخل طرز پیاده‌سازی خود ابزار و روش‌های مختلفی که وجود دارند عمیق شده است. از طرفی حاصل مقایسه‌ها هم خیلی به روش‌های مختلفی که در مقالات مختلف توضیح داده شده‌اند بستگی دارد و نام بردن از آن‌ها بدون اطّلاع از این که هر کدام چه کار می‌کنند چندان منطقی به نظر نمی‌رسد. پس تمرکز اصلی این متن روی دسته‌بندی‌های مختلفی است که در مقاله صورت گرفته.
به طور کلّی برای من کمی عجیب بود که(طبق ادّعای مقاله) تا قبل از این، پیاده‌سازی‌های روش‌های مختلف به خوبی منتشر نمی‌شدند؛ این طور برداشت می‌شود که «هر کسی می‌آمد و یک روشی برای خودش می‌داد و چندان هم نمی‌توانست مقایسه‌ی معتبری بین حاصل کار خودش و پیشینیان انجام دهد.» و البته نکته‌ای که برایم جالب بود این بود که در مورد اکثر این دسته‌بندی‌ها به نظر می‌رسد به راحتی می‌توان آن‌ها را با یکدیگر ترکیب کرد و روش‌های جدید ابداع کرد؛ یا مثلا از یکی از آن‌ها برای بهینه‌سازی قسمتی از یکی دیگر استفاده کرد.(مانند استفاده از روش‌های dynamic برای پیدا کردن CFG)

روش‌های مختلف تشخیص آسیب‌پذیری:
این روش‌ها در بالاترین سطح به ۲ دسته تقسیم می‌شوند: static و dynamic

رویکردهای static برنامه را بدون اجرا کردن آن تحلیل می‌کنند. این‌ها به دو دسته تقسیم می‌شوند. در یک دسته برنامه به شکل یک گراف(مثلا CFG) مدل‌سازی می‌شود و در دسته‌ی دیگر داده‌ها با روش‌های مختلف مدل‌سازی می‌شوند.
در رویکردهای static ایراد معمول این است که آسیب‌پذیری‌های گزارش شده لزوما قابل تکرار نیستند و در نهایت با روش دیگری باید چک شود که آیا آسیب‌پذیری‌های گزارش شده در واقعیت امکان رخ دادن دارند یا نه. البته با تقریب خوبی می‌توان گفت تمام آسیب‌پذیری‌های موجود گزارش می‌شوند.
	در روش‌های مبتنی بر گراف معمولا هر آسیب‌پذیری به شکل یک دنباله از رئوس گراف مدل می‌شود. خود یافتن CFG لزوما یک مساله‌ی سرراست نیست و به دلیل وجود دستورات indirect jump گاهی خیلی پیچیده می‌شود؛ پس حول مساله‌ی یافتن CFG هم تحقیقاتی صورت می‌گیرد.
	یک روش معروف مبتنی بر مدل‌سازی داده‌ها Value-Set Analysis است که در آن تلاش می‌شود تخمینی در مورد وضعیت مقادیر مختلف(در حافظه و رجیسترها و...) در هر نقطه از برنامه به دست آید و با استفاده از این تخمین‌ها رفتار برنامه تحلیل شود.

رویکردهای dynamic برنامه را با تحلیل رفتار آن در حین اجرا بررسی می‌کنند. آسیب‌پذیری‌هایی که می‌یابند معمولا قابل تکرار هستند.
این‌ها به دو دسته تقسیم می‌شوند: اجرای concrete و symbolic
	دسته‌ی اوّل: معمول‌ترین روش fuzzing است که ورودی‌های تصادفی به برنامه داده می‌شود. اگر ورودی باعث crash برنامه شود یعنی یک باگ پیدا شده است. برای بهبود کارایی، تکنیک‌هایی وجود دارد مثل بیشینه کردن coverage یا بررسی تاثیر قسمت‌های مختلف ورودی بر قسمت‌های مختلف روند اجرا.
	دسته‌ی دوم: ورودی‌ها به طور نمادین در نظر گرفته می‌شوند و مسیرهای اجرای مختلف بررسی می‌شوند. امّا تعداد مسیرهای مختلف می‌تواند به طور نمایی زیاد شود. هر انشعاب در روند اجرا، روی مسیر منشعب شده یک شرط اضافه می‌کند. برای تولید یک مسیر، باید یک ورودی پیدا شود که تمام شروطش را محقّق کند. از این روش‌ها برای شبیه‌سازی قسمت‌های کوچکی از یک برنامه(مثلا یک تابع به تنهایی) هم می‌توان استفاده کرد.

در قسمت ۵ام مقاله به این نکته اشاره می‌شود که بازتولید crashها مثلا به دلیل de-randomization چندان آسان نیست؛ همچنین هر crash لزوما قابل اکسپلویت کردن نیست و اگر باشد هم ممکن است روش‌هایی مانند ASLR و W^X جلوی آن را بگیرند.

