**Imagine that we have 2\*\*48 text files. Explain how can we find which files are the same.**

‫در گام اوّل، می‌توان فرض کرد که حجم هر فایل حداکثر ۳۲ بایت است؛ یعنی اگر بیشتر یا مساوی ۳۲ بایت بود، می‌توانیم به جای محتویاتش `md5sum‍`ش را در نظر بگیریم و مساله به این شکل مدل می‌شود که تعدادی رشته با طول حداکثر ۳۲ داریم و می‌خواهیم رشته‌های مساوی را پیدا کنیم. در ادامه یک راه حل عملی برای این کار بیان می‌شود؛ در بیان این راه حل مقداری جزییات نیز بیان می‌شوند.

‫پس به ترتیب چنین دغدغه‌هایی داریم:
* هش تمام پرونده‌ها را محاسبه کنیم
* داده‌ساختار مناسبی برای نگه‌داری هش‌ها و فایل متناظرشان داشته باشیم
* با استفاده از آن داده‌ساختار رشته‌های مساوی را بیابیم

### محاسبه‌ی هش پرونده‌ها
‫به این منظور یک سرویس به نام Hasher تعریف می‌کنیم؛ وظیفه‌ی این سرویس این است که به ازای تعدادی پرونده‌ی مشخّص، هش آن‌ها را محاسبه کند و اطّلاعات به دست آمده را در داده‌ساختار مذکور ذخیره کند.

‫از آن جایی که 2**48 عدد بسیار بزرگی است، لازم است تا جای ممکن پردازش‌ها به طور موازی انجام شوند. در سطح یک کامپیوتر، مثلا دسترسی به دیسک سخت می‌تواند به طور موازی صورت بگیرد(به طور خاص فکر می‌کنم تکنولوژی NVMe بسیار مناسب این کار است) و یا در سطح بالاتر، پرونده‌ها می‌توانند بین چندین کامپیوتر توزیع شوند و روی هر کامپیوتر تعدادی از این سرویس‌های Hasher اجرا شود.

### داده‌ساختار مناسب
‫به عنوان داده ساختار مطلوب برای نگه‌داری اطّلاعات(دوتایی‌های <هش، آدرس فایل>) ۲ روش به ذهن می‌رسد.
‫روش اوّل پیاده‌سازی پیچیده‌تری دارد و حافظه‌ی بیشتری مصرف می‌کند امّا به راحتی حتّی در حین اجرای سیستم scale می‌شود.
‫روش دوم پیاده‌سازی ساده‌تری دارد ولی برای این که به طور بهینه فعّالیّت کند باید چندین کامپیوتر در دسترس باشد.

* ‫از یک Trie برای ذخیره‌ی هش‌ها استفاده کنیم و در هر گره لیستی از فرزندان آن گره ذخیره خواهد شد و همچنین آدرس فایل‌هایی که رشته‌ی متناظرشان(هش یا محتوا) به آن گره ختم می‌شود را در یک لیست ذخیره کنیم. این داده‌ساختار قابلیت توزیع‌شوندگی نیز دارد، به این شکل که روی هر کامپیوتر یک یا چند سرویس خواهیم داشت و هر سرویس مسئول نگه‌داری زیرمجموعه‌ای از گره‌های Trie کلّی است. بدیهی است فرزندان یک گره ممکن است روی همان سرویس ذخیره شده باشند یا روی یک سرویس/کامپیوتر دیگر.
* ‫تعدادی سرویس ساده‌ی ذخیره‌سازی key/value(مانند Redis) داشته باشیم و روی کامپیوترهای مختلفی این سرویس را اجرا کنیم. هر کامپیوتر مسئول نگه‌داری هش‌های مشخّصی می‌شود. مثلا یک کامپیوتر فقط هش‌هایی را نگه‌داری می‌کند که با حرف a شروع می‌شوند و یک کامپیوتر آن‌هایی که با ba شروع می‌شوند و... منظور از key همان هش‌هاست و منظور از value نیز لیستی از آدرس فایل‌ها است.

‫احتمالا روش دوم واقعا روش مطلوب‌تری باشد؛ چون سیستم‌های ذخیره‌ی key/value بسیار پیشرفته در حال حاضر وجود دارند.

### یافتن رشته‌های برابر
‫چنان چه از Trie به عنوان داده‌ساختار استفاده کرده باشیم، کافی است آن را پیمایش کنیم(مشابه DFS) و در هر گره لیست فایل‌های برابر موجود خواهد بود. این پیمایش‌گرها نیز می‌توانند در هر گره که بیش از یک فرزند دارد fork شوند تا کار با سرعت بیشتری انجام شود.

‫اگر از روش دیگر به عنوان داده‌ساختار استفاده شود هم کافی است در انتها هر سرویس روی key/valueهایش حرکت کند تا به ازای هر key ببیند چه پرونده‌هایی متناظر آن هستند.
